# Dynamic Programming (동적 계획법)
DP는 코딩 테스트의 백미다. 사실 모든 알고리즘 문제들은 완전 탐색을 이용해 정답을 도출할 수 있다.
단지 비효율적인 연산과 시간을 없애고, 답을 효율적으로 도출하기 위해 여러 알고리즘 기법이 생기게 된 것인데
동적 계획법, DP는 이 중 가장 광범위한 여러 유형의 문제를 논리적인 사고를 이용해 효율적으로 풀 수
있는 알고리즘이다.

> DP는 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한
> 문제의 답을 구하는 방법을 뜻한다.


## 동적 계획법의 핵심 이론
- 동적 계획법의 원리와 구현 방식
  1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
  2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결과값은 항상 같아야 한다.
  3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP테이블을
  이용한다. 이를 메모이제이션(memoization) 기법이라고 한다.
  4. 동적 계획법은 top-down 방식과 bottom-up 방식으로 구현할 수 있다.

## 피보나치 수열을 DP로 풀어보기

> 피보나치 수열 공식 : D[N] = D[N-1] + D[N-2]

1. 동적 계획법으로 풀 수 있는지 확인하기
  - 6번째 피보나치 수열을 구하는 것을 생각해보자.
  - 6번째 피보나치 수열은 5번째 피보나치 수열과 4번째 피보나치 수열을 구하는 작은 문제로 나눌 수 있다.
  - 수열의 값은 항상 같기 때문에 동적 계획법으로 풀 수 있다.
2. 점화식 세우기
  - 피보나치 수열은 공식 자체가 점화식임
  - 즉, D[i] = D[i-1] + D[i-2]
3. 메모이제이션 원리 이해하기
   - 메모이제이션은 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장하고 다음에 같은 문제가
   나왔을 때 재계산하지 않고 DP 테이블의 값을 이용하는 것을 말한다.
   - 예를 들어 5번째 피보나치 수열을 구할 때 2번째와 3번째 피보나치 수열은 맨 왼쪽 탐색
   부분에서 최초로 값이 구해지고, 이때 DP 테이블에 값이 저장된다.
   - 이에 따라 나중에 2번째와 3번째 피보나치 수열의 값이 필요할 때 재연산을 이용해 구하지 않고, 
   DP 테이블에서 바로 값을 추출한다.
   - 이러한 방식을 사용하여 불필요한 연산과 탐색이 줄어들어 시간 복잡도 측면에서 많은 이점을 가질
   수 있다.
4. Top-down 구현 방식 이해하기
  ```java
  import java.util.Scanner;
  
  public class fibonacci {
    static int[] D;
    public static void main(String[] args) {
      Scanner scan = new Scanner(System.in);
      int n = scan.nextInt();
      D = new int[n+1];
  
      for(int i=0; i<=n ; i++){
        D[i] = -1;
      }
  
      D[0] = 0;
      D[1] = 1;
  
      fiboTopDown(n);
  
      System.out.println(D[n]);
    }
  
    static int fiboTopDown(int n){
      if (D[n] != -1) //기존에 계산한 적이 있는 부분의 문제는 재계산하지 않고 리턴
        return D[n];
      
      // Memoization : 구한 값을 바로 리턴하지 않고 DP 테이블에 저장한 후 리턴하도록 로직을 구현
      return D[n] = fiboTopDown(n-1) + fiboTopDown(n-2);
    }
  }
  ```
  - Top-down 방식은 말 그대로 위에서부터 문제를 파악해 내려오는 방식으로, 주로 재귀
  함수 형태로 코드를 구현한다.
  - 코드의 가독성이 좋고, 이해하기 편하다는 장점이 있다.
5. Bottom-up 구현 방식 이해하기
  ```java
  import java.util.Scanner;
  
  public class fibonacci {
    static int[] D;
    public static void main(String[] args) {
      Scanner scan = new Scanner(System.in);
      int n = scan.nextInt();
      D = new int[n+1];
  
      for(int i=0; i<=n ; i++){
        D[i] = -1;
      }
  
      D[0] = 0;
      D[1] = 1;
      
      fiboBottomUp(n);
  
      System.out.println(D[n]);
    }
  
    static void fiboBottomUp(int n){
      for(int i=2; i<=n; i++){
        D[i] = D[i-1] + D[i-2];
      }
    }
  }
  ```
  - 가장 작은 부분의 문제부터 해결하면서 점점 큰 문제로 확장해 나가는 방식이다.
  - 주로 반복문 형태로 구현한다.

> 두 방식 중 좀 더 안전한 방식은 Bottom-up이다. Top-down 방식은 재귀 함수의 형태로 구현
> 되어 있어 재귀의 깊이가 매우 깊어질 경우 런타임 에러가 발생할 수 있다. 하지만 실제 코딩 테스트
> 에서 이 부분까지 고려해야 하는 난이도는 잘 나오지 않는다. 오히려 자신이 구현한 함수에 버그가 있을
> 확률이 더 높을 것이다. 이 부분을 제외하면 두 방식의 차이점은 거의 없기 때문에 자신에게 좀 더 편한
> 방식이나 문제에 따라 두 방식 중 1개를 선택해 사용하면 된다. 동적 계획법은 매우 중요하므로 가장 많은
> 문제를 다룰 예정이다.